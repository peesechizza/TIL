# Chapter 11. CPU 스케줄링

## 11-1. CPU 스케줄링 개요

모든 프로세스는 CPU를 필요로 하고 사용하고 싶어한다. 운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 `CPU 스케줄링`이라고 한다.

### 프로세스 우선순위

프로세스마다 `우선순위`가 있다. 우선순위가 높은 프로세스란 빨리 처리해야 하는 프로세스들을 의미하고, 대표적으로 입출력 작업이 많은 프로세스가 있다.

대부분의 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행된다. 실행 상태와 대기 상태를 반복하며 실행되는 것이다. 

프로세스 종류마다 입출력장치를 이용하는 시간과 CPU를 이용하는 시간의 양에는 차이가 있다. 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스도 있고, 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스도 있다. 전자를 `입출력 집중 프로세스` (I/O bound process)라 하고 실행 상태보다 입출력을 위한 대기 상태에 더 많이 머무른다. 후자를 `CPU 집중 프로세스` (CPU bound process) 라고 하고, 대기 상태보다는 실행 상태에 더 많이 머무르게 된다.

모든 프로세스가 CPU를 차례대로 돌아가며 사용하는 것보다 각각의 상황에 맞게 CPU를 배분하는 것이 더 효율적이다. 상황에 맞게, 그리고 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스마다 `우선순위` 를 부여한다.

운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

### CPU 버스트와 입출력 버스트

CPU를 이용하는 작업을 `CPU 버스트` 라 하고, 입출력장치를 기다리는 작업을 `입출력 버스트`라 부른다. 프로세스는 일반적으로 CPU 버스트와 입출력 버스트를 반복하며 실행된다고 볼 수 있다. 입출력 집중 프로세스는 입출력 버스트가 많은 프로세스, CPU 집중 프로세스는 CPU 버스트가 많은 프로세스라고 정의할 수 있다.

### 스케줄링 큐

CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다. 

운영체제는 프로세스들을 줄을 세워 관리하는데, 이 줄을 `스케줄링 큐`로 구현하고 관리한다. 스케줄링 큐에는 `준비 큐` 와 `대기 큐` 가 있다. 준비큐는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미하고, 대기 큐는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미한다.

### 선점형과 비선점형 스케줄링

하나의 프로세스가 자원을 사용하고 있을 때 다른 프로세스가 해당 자원을 빼앗을 수 있는 스케줄링을 `선점 스케줄링`, 빼앗을 수 없는 스케줄링을 `비선점 스케줄링` 이라고 한다.

선점형 스케줄링은 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

비선점형 스케줄링은 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적지만, 모든 프로세스가 골고루 자원을 사용할 수 없다는 단점이 있다.

## 11-2. CPU 스케줄링 알고리즘

### 선입 선처리 스케줄링

선입 선처리 스케줄링은 `FCFS 스케줄링 (First Come First Server)` 이라고도 부른다. 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다. 

이 스케줄링 방식은 때때로 프로세스들이 기다리는 시간이 매우 길어질 수 있다는 점에서 부작용이 있는 방식이다.

모든 다른 프로세스들이 하나의 긴 프로세스가 CPU를 양도하기를 기다리는 것을 `호위 효과(convoy effect)` 라 한다.

### 최단 작업 우선 스케줄링

준비 큐에 삽입된 프로세스들 중 CPU 이용 시간의 길이가 가장 짧은 프로세스부터 실행하는 스케줄링 방식을 `최단 작업 우선 스케줄링 (SJF; Shortest Job First)`이라고 한다. 최단 작업 우선 스케줄링은 기본적으로 비선점형 스케줄링 알고리즘으로 분류되지만, 선점형으로 구현될 수도 있다.

### 라운드 로빈 스케줄링

정해진 타임 슬라이스만큼의 시간 동안 돌아가며 CPU를 이용하는 선점형 스케줄링이다. (선입 선처리 스케줄링 + 타임슬라이스) `타임 슬라이스` 란 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.

라운드 로빈 스케줄링에서는 타임 슬라이스 크기가 매우 중요하다. 지나치게 크면 선입 선처리 스케줄링과 다를 바 없고, 지나치게 작으면 문맥 교환에 발생하는 비용이 커 CPU는 프로세스를 처리하는 일보다 프로세스를 전환하는 데에 온 힘을 다 쓸 여지가 있기 때문이다.

### 최소 잔여 시간 우선 스케줄링

`최소 잔여 시간 우선 스케줄링 (SRT; Shortest Remaining Time)` 은 최단 작업 스케줄링 알고리즘과 라운드 로빈 스케줄링을 합친 스케줄링 방식이다.

프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.

### 우선순위 스케줄링

프로레스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스부터 실행하는 스케줄링 알고리즘이다.

준비 큐에 먼저 삽입된 우선순위가 낮은 프로세스가 우선순위가 높은 프로세스들에 의해 실행이 계속 연기될 수 있는 현상을 `기아 현상`이라고 한다.

이를 방지하기 위해 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 `에이징` 방식이 있다. 

### 다단계 큐 스케줄링

우선순위별로 준비 큐를 여러 개 사용하는 스케줄링 방식이다. 다단계 큐 스케줄링 하에서는 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 가장 높은 큐가 비어 있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리한다.

큐를 여러 개 두면 프로세스 유형별로 우선순위를 구분하여 실행하는 것이 편리해진다.

### 다단계 피드백 큐 스케줄링

다단계 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 없기 때문에 기아 현상이 발생할 수 있는데, 이를 보완한 스케줄링이 `다단계 피드백 큐 스케줄링` 이다.

비슷하게 작동되지만, CPU를 비교적 오래 사용해야 하는 CPU 집중 프로세스들은 자연스레 우선순위가 낮아지고, CPU를 비교적 적게 사용하는 입출력 집중 프로세스들은 자연스레 우선순위가 높은 큐에서 실행이 된다.

다단계 피드백 큐 스케줄링은 프로세스들이 큐 사이를 이동할 수 있는 방식이기 때문에 낮은 우선순위 큐에서 너무 오래 기다리고 있는 프로세스가 있다면 점차 우선순위가 높은 큐로 이동시키는 에이징 기법을 적용하여 기아 현상을 예방할 수 있다.