# Chapter 03. 명령어

## 03-1. 소스 코드와 명령어

명령어는 컴퓨터를 실질적으로 작동시키는 매우 중요한 정보이다. 프로그래밍 언어로 만든 모든 소스 코드는 컴퓨터 내부에서 명령어로 변환되어 컴퓨터에서 실행된다.

### 고급 언어와 저급 언어

**고급 언어**

우리가 프로그램을 만들 때 사용하는 프로그래밍 언어는 컴퓨터가 이해하는 언어가 아닌 **사람이 이해하고 작성**하기 쉽게 만들어진 언어이다. 우리가 알고 있는 대부분의 프로그래밍 언어가 고급 언어에 속한다.

고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어(명령어)로 변환되어야 한다.

**저급 언어**

**컴퓨터가 직접 이해하고 실행**할 수 있는 언어로, 명령어로 이루어져 있다.

저급 언어에는 두 가지 종류가 있다.

- 기계어
  0과 1로 이루어진 명령어로 구성된 저급 언어이다. 기계어를 이진수로 나열하면 너무 길어져 가독성을 해치기 때문에 십육진수로 표현하기도 한다.
- 어셈블리어
  0과 1로 이루어진 기계어를 읽기 편한 형태로 번역한 저급 언어이다. 어셈블리어를 읽으면 컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 어떤 절차로 작동하는지를 가장 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있다.

### 컴파일 언어와 인터프리터 언어

개발자들이 고급 언어로 작성한 소스 코드를 저급 언어로 변환되는 방식에는 두 가지, **컴파일 방식**과 **인터프리터 방식**이 있다.

**컴파일 언어**

컴파일 언어는 **컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행**되는 고급 언어이다. 이 과정을 **컴파일** 이라고 하고, 컴파일을 수행해 주는 도구를 **컴파일러**라고 한다. 대표적인 컴파일 언어로는 C언어가 있다.

컴파일러는 개발자가 작성한 소스 코드 전체를 쭉 훑어보며 소스 코드에 문법적인 오류는 없는지, 실행 가능한 코드인지, 실행하는 데 불필요한 코드는 없는지 등을 따지며 소스 코드를 처음부터 끝까지 저급 언어로 컴파일한다. 이때 컴파일러가 소스 코드 내에서 오류를 발견하게 되면 해당 소스 코드는 컴파일에 실패하게 된다.

컴파일이 성공적으로 수행되면 개발자가 작성한 소스 코드는 컴퓨터가 이해할 수 있는 저급 언어로 변환된다. 이렇게 **컴파일러를 통해 저급 언어로 변환된 코드**를 **목적 코드**라고 한다.

**인터프리터 언어**

**인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언**어이다. 대표적인 인터프리터 언어로 Python이 있다.

인터프리터 언어는 소스 코드를 한 줄씩 차례로 실행한다. 그리고 소스 코드를 한 줄씩 저급 언어로 변환하여 실행해 주는 도구를 **인터프리터** 라고 한다. 컴파일 언어와 달리 소스 코드 내에 오류가 있더라도 오류가 있는 소스 코드의 앞 줄까지 올바르게 수행된다.

> **컴파일 언어와 인터프리터 언어 구분**
>
> 하나의 프로그래밍 언어가 반드시 둘 중 하나의 방식만으로 작동한다고 생각하는 것은 오개념이다. Python도 컴파일을 하지 않는 것은 아니며, Java의 경우 저급 언어가 되는 과정에서 컴파일과 인터프리터를 동시에 수행한다.
>
> 컴파일이 가능한 언어라고 해서 인터프리트가 불가능하거나, 인터프리트가 가능한 언어라고 해서 컴파일이 불가능한 것은 아니다. 따라서 모든 프로그래밍 언어를 컴파일 언어와 인터프리터 언어로 구분하기 보다는 **고급 언어가 저급 언어로 변환되는 대표적인 방법에는 컴파일 방식과 인터프리트 방식이 있다** 라는 정도로 이해하는 것이 좋다.

### 목적 파일과 실행 파일

**목적 코드로 이루어진 파일을 목적 파일** 이라고 부르고, **실행 코드로 이루어진 파일을 실행 파일**이라고 부른다. 윈도우의 .exe 확장자를 가진 파일이 대표적인 실행 파일이다.

목적 코드가 실행 파일이 되기 위해서는 **링킹**이라는 작업을 거쳐야 한다. 링킹은 컴파일 언어의 소스로부터 목적 코드가 생성되고, 목적 파일이 실행되면 목적 파일에 없는 외부 기능들을 연결 짓는 작업이다. 링킹 작업까지 거치면 비로소 하나의 실행 파일이 만들어진다.

## 03-2. 명령어의 구조

### 연산 코드와 오퍼랜드

**명령어**는 연산 코드와 오퍼랜드로 구성되어 있다. **명령어가 수행할 연산을 연산 코드(operation code)** 라 하고, **연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 오퍼랜드(operand)** 라고 한다. **연산 코드는 연산자**, **오퍼랜드는 피연산자**라고도 부른다.

연산 코드가 담기는 영역을 연산 코드 필드라고 부르고, 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다.

기계여와 어셈블리어도 명령어이기 때문에 연산 코드와 오퍼랜드로 구성되어 있다.

**오퍼랜드**

오퍼랜드는 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치를 의미한다. 오퍼랜드 필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있다. 다만 오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데이터를 직접 명시하기보다는, 많은 경우 **데이터가 저장된 위치를 명시**한다. 즉, **메모리 주소나 레지스터 이름이 담기고, 주소 필드**라고 부른다.

오퍼랜드가 하나도 없는 명령어를 0-주소 명령어라고 하고,하나인 명령어를 1-주소 명령어, 2-주소 명령어, 3-주소 명령어라고 한다.

**연산 코드**

연산 코드는 명령어가 수행할 연산을 의미한다. 종류는 매우 많지만, 가장 기본적인 연산 코드는 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어 이렇게 크게 4가지가 있다.

명령어의 종류와 생김새는 CPU마다 다르기 떄문에 여산 코드의 종류와 생김새 또한 CPU마다 다르다.

1. **데이터 전송**
   - **MOVE :** 데이터를 옮겨라
   - **STORE :** 메모리에 저장하라
   - **LOAD (FETCH) :** 메모리에서 CPU로 데이터를 가져와라
   - **PUSH :** 스택에 데이터를 저장하라
   - **POP :** 스택의 최상단 데이터를 가져와라
2. **산술/논리 연산**
   - **ADD / SUBSTRACT / MULTIPLY / DIVIDE**
   - **INCREMENT / DECREMENT**
   - **AND / OR / NOT: AND / OR / NOT**
   - **COMPARE :** 두 개의 숫자 또는 TRUE / FALSE 값을 비교
3. **제어 흐름 변경**
   - **JUMP :** 특정 주소로 실행 순서를 옮겨라
   - **CONDITIONAL JUMP :** 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
   - **HALT :** 프로그램의 실행을 멈춰라
   - **CALL :** 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
   - **RETURN :** CALL을 호출할 때 저장했던 주소로 돌아가라
4. **입출력 제어**
   - **READ (INPUT)**
   - **WRTIE (OUTPUT)**
   - **START IO**
   - **TEST IO**

### 주소 지정 방식

명령어의 오퍼랜드 필드에 연산코드, 연산 코드에 사용될 데이터 형식이 아닌 메모리나 레지스터의 주소를 담는 이유는 명령어 길이 때문이다. 메모리 주소나 레지스터 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소나 레지스터의 주소에 저장할 수 있는 공간만큼 커진다.

**연산 코드에 사용할 데이터가 저장된 위치, 연산의 대상이 되는 데이터가 저장된 위치를 유효 주소(effective address)** 라고 한다.

오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 **연산에 사용할 데이터 위치를 찾는 방법을 주소 지정 방식(addressing mode)** 라고 한다. 주소 지정 방식은 유효 주소를 찾는 방법이다.

**즉시 주소 지정 방식(Immediate addressing mode)**

**연산에 사용할 데이터**를 **오퍼랜드 필드에 직접 명시하는 방식**이다. 가장 간단한 형태의 주소 지정 방식이다. 이런 방식은 표현할 수 있는 데이터의 크기가 작아지는 단점이 있지만 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 이하 설명할 주소 지정 방식들보다 빠르다.

**직접 주소 지정 방식(direct addressing mode)**

오퍼랜드 필드에 **유효 주소를 직접적으로 명시**하는 방식이다. 오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 즉시 주소 지정 방식보다 더 커졌지만 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다. 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.

**간접 주소 지정 방식(indirect addressing mode)**

**유효 주소의 주소를 오퍼랜드 필드에 명시**한다. 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어졌다. 하지만 두 번의 메모리 접근이 필요하기 때문에 앞의 주소 지정 방식들보다 느린 방식이다.

**레지스터 주소 지정 방식(register addressing mode)**

직접 주소 지정 방식과 비슷하게 **연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시**하는 방법이다.

일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다. 그러므로 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있다. 하지만 레지스터 주소 지정 방식은 직접 주소 지정 방식과 비슷한 문제를 공유한다. 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다는 점이다.

**레지스터 간접 주소 지정 방식(register indirect addressing mode)**

**연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시**하는 방법이다.

유효 주소를 찾는 과정이 간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 한 번으로 줄어든다는 차이와 장점이 있다. 레지스터 간접 주소 지정 방식은 간접 주소 지정 방식보다 빠르다.

### 스택과 큐

**스택**이란 한쪽 끝이 막혀 있는 통과 같은 저장 공간이다. 한쪽 끝이 막혀 있어서 데이터를 차곡차곡 저장하고, 저장한 자료를 빼낼 때는 마지막으로 저장한 데이터부터 빼낸다. **나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출)로 LIFO(Last In First Out) 자료 구조**라고 한다.

스택에 새로운 데이터를 저장하는 명령어가 **PUSH**, 스택에 저장된 데이터를 꺼내는 명령어가 POP이다. POP 명령어를 수행하면 스택의 최상단에 있는(Last In) 마지막으로 저장한 데이터부터 꺼내게 된다(First Out).

스택과는 달리 양쪽이 뚫려 있는 통과 같은 저장 공간을 **큐**라고 한다. 큐는 한쪽으로는 데이터를 저장하고, 다른 한쪽으로는 먼저 저장한 순서대로 데이터를 빼낸다. **가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식(선입선출)로 FIFO(First In First Out) 자료 구조**라고 한다.
