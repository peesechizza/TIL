# 9. React version 18

## Automatic batching

batching은 업데이트 대상이 되는 상태값들을 하나의 그룹으로 묶어서 한번의 re-rendering에 업데이트가 모두 진행될 수 있게 해주는 것을 의미한다.

함수의 끝에서 업데이트가 되며 리액트는 마지막에 한번만 리렌더링 한다.

batch update를 사용함으로 불필요한 리렌더링을 줄일 수 있어서 큰 이점을 얻을 수 있는데, 이전 버전에서도 batch update가 지원되었지만 클릭과 같은 브라우저 이벤트에서만 적용이 가능하고 api 호출에 콜백으로 넣은 함수나 timesout 함수에서는 작동하지 않았다.

1. 더 나은 성능 위한 더 적은 리렌더링을 한다.
2. 이벤트 핸들러 밖에서 작동한다.
3. 필요할 때는 제외할 수 있다.

### batch 처리하지 않기

일반적으로 일괄 처리는 안전하지만 일부 코드는 상태 변경 직후 DOM에서 무언가를 읽는데 의존할 수 있다. 이러한 경우 `ReactDoM.flushSync()`을 사용하여 리액트가 바로 DOM 업데이트를 할 수 있게 한다.

## Suspense on the server

서스펜스는 클라이언트 사이드 렌더링을 할 때 사용했는데, 서버 사이드 렌더링에서도 사용할 수 있게 되었다.

### 서버 사이드 렌더링

1. 서버에서 전체 앱에 대한 데이터를 가져온다.
2. 서버에서 전체 앱을 HTML로 렌더링하고 응답으로 보낸다.
3. 클라이언트에서 전체 앱에 대한 JavaScript 코드를 로드한다.
4. 클라이언트에서 JavaScript 논리를 전체 앱에 대해 서버 생성 HTML에 연결한다. (Hydration : HTML에 Javascript 공급하기)

https://github.com/reactwg/react-18/discussions/37

### suspense

다음 단계가 시작되기 전에 각 단계가 전체 앱에 한 번에 완료되어야 한다. 이렇게 되면 앱의 일부가 다른 부분보다 느린 경우 효율적이지 않다.

`<Suspense />`를 사용하여 앱을 더 작은 독립 단위로 나눌 수 있다. 이 단위는 서로 독립적으로 단계를 거치며 앱의 나머지 부분을 차단하지 않는다.

## Transition

React 18 에서는 업데이트 중에도 앱의 응답성을 유지하는데 도움이 되는 새로운 API를 도입한다. API를 사용하면 특정 업데이트를 Transition으로 표시하여 사용자 상호 작용을 크게 개선할 수 있다. React를 사용하면 상태 전환 중에 시각적 피드백을 제공하고 전환이 발생하는 동안 브라우저의 응답성을 유지할 수 있다.

이 기능은 리액트에서 어떠한 업데이트가 Urgent 하거나 아닌지 알려주기 때문에 업데이트를 하는데 우선순위를 주게 된다.

검색 기능을 구현할 때 검색하는 input 은 이벤트에 따라서 리렌더링이 해당 화면에 업데이트 되어야 한다. 검색 결과도 이에 따라 업데이트가 되는데 검색 결과 리스트가 많지 않더라도 내부적으로 검색 결과를 가져오는데 많은 작업을 진행할 수 있기 때문에 성능에 문제가 생길 수 있다.

- Urgent Updates, 검색창
    - 버튼 클릭, 키보드 입력과 같이 직관적으로 보았을 때 업데이트가 즉각적으로 일어나는 것을 기대하는 상태 값들을 대상으로 한다.
- Transition Updates, 결과창
    - 사용자가 상태 값의 변화에 따른 모든 업데이트가 뷰에 즉각적으로 일어나는 것을 기대하지 않는다.

### startTransition API

업데이트를 “Transition”으로 표시할 수 있는 기능을 제공하여 이 문제를 해결한다. 이 API로 리액트에게 상태 업데이트 하는데 우선 순위를 정해주는 것이다.
startTransition에 래핑된 업데이트는 긴급하지 않은 것으로 처리되며 클릭이나 키 누름과 같은 더 긴급한 업데이트가 들어오는 경우 중단된다.
Transition을 사용하면 UI가 크게 변경되더라도 대부분의 상호 작용을 빠르게 유지할 수 있다.

### Transition이 보류 중일 때

검색 창에 타이핑을 했을 때 startTransition API로 인해 결과창에는 UI 업데이트 우선순위가 밀려서 보류가 일어날 때는 isPending이 true로 된다.

### startTransition이 없을 때

1. State를 두 개로 나눠서 따로 처리하기
2. debounce를 이용해서 처리하기
3. setTimeout을 이용해서 처리하기