# Chapter 4. CPU의 작동 원리

## 04-1. ALU와 제어장치

### ALU

ALU는 CPU 내부에서 계산을 담당하는 장치이다. ALU가 계산을 하기 위해서는 피연산자와 수행할 연산이 필요한데, **레지스터를 통해 피연산자**를 받아들이고, **제어장치로부터 수행할 연산을 알려주는 제어 신호**를 받아들인다.

연산을 수행한 결과값은 바로 메모리에 저장되지 않고 일시적으로 레지스터에 저장된다. CPU가 메모리에 접근하는 속도가 느리기 때문에 ALU가 연산할 때마다 메모리에 결과값을 저장하게 된다면 성능이 저하될 것이다.

**플래그**

ALU는 계산 결과와 더불어 **플래그**를 내보낸다. 플래그는 연산 결과에 대한 추가적인 상태 정보이다.

- 부호 플래그
  - 연산한 결과의 부호를 나타냄
  - 1일 경우 계산 결과는 음수, 0일 경우 계산 결과는 양수
- 제로 플래그
  - 연산 결과가 0인지의 여부
  - 1일 경우 연산 결과 0, 0일 경우 연산 결과 0 아님
- 캐리 플래그
  - 연산 결과 올림수나 빌림수가 발생했는지 여부
  - 1일 경우 발생, 0일 경우 아님
- 오버플로우 플래그
  - 오버플로우가 발생했는지 여부
  - 1일 경우 발생, 0일 경우 아님
- 인터럽트 플래그
  - 인터럽트가 가능한지 나타냄
  - 1일 경우 가능, 0일 경우 불가능
- 슈퍼바이저 플래그
  - 커널 모드 또는 사용자 모드로 실행 중인지 나타냄
  - 1일 경우 커널 모드, 0일 경우 사용자 모드

> **오버플로우(overflow)**
>
> 연산 결과가 연산 결과를 담을 레지스터보다 큰 상황

이러한 플래그는 CPU가 프로그램을 실행하는 도중 반드시 기억해야 하는 참고 정보이며 플래그 레지스터라는 레지스터에 저장된다.

### 제어장치

제어장치는 제어 신호를 내보내고, 명령어를 해석하는 부품이다. 제어 신호는 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호이다.

- **제어장치는 클럭 신호를 받아들인다.**

  **클럭**이란 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위이다. 컴퓨터의 모든 부품이 한 클럭마다 작동하는 것이 아니라 클럭이라는 박자에 맞춰 작동할 뿐 여러 클럭에 걸쳐 실행될 수도 있다.

- **제어장치는 해석해야 할 명령어를 받아들인다.**

  CPU가 해석해야 할 명령어는 **명령어 레지스터**에 저장된다. 제어장치는 이 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜 컴퓨터 부품들에 수행해야 할 내용을 알려준다.

- **제어장치는 플래그 레지스터 속 플래그 값을 받아들인다.**

  제어장치는 ALU 연산에 대한 추가적인 상태 정보인 플래그 값을 받아들이고 이를 참고하여 제어 신호를 발생시킨다.

- **제어장치는 시스템 버스인 제어 버스로 전달된 제어 신호를 받아들인다.**
  제어 신호는 CPU뿐만 아니라 입출력 장치를 비롯한 CPU 외부 장치도 발생시킬 수 있다. 제어장치는 제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들이기도 한다.

**제어 장치가 내보내는 정보**

제어 장치는 CPU 내부와 외부로 제어 신호를 보낸다.

CPU 외부에 제어 신호를 전달하는 것은 제어 버스로 제어 신호를 내보내는 것이다. 이러한 제어 신호에는 크게 메모리에 전달하는 제어 신호와 입출력장치(보조기억장치 포함)에 전달하는 제어 신호가 있다.

제어 장치가 CPU 내부에 전달하는 제어 신호에는 크게 ALU에 전달하는 제어 신호와 레지스터에 전달하는 제어 신호가 있다.

## 04-2. 레지스터

명령어와 데이터는 실행 전후로 반드시 레지스터에 저장된다. 저장된 값들만 잘 관찰해도 프로그램의 자세한 실행 과정을 알 수 있다.

### 반드시 알아야 할 레지스터

1. **프로그램 카운터 (PC; Program Counter)**

   프로그램 카운터는 메모리에서 가져올 명령어의 주소, 즉 **메모리에서 읽어 들일 명령어의 주소를 저장**한다. 명령어 포인터(IP; Instruction Pointer) 라고 부르는 CPU도 있다.

2. **명령어 레지스터 (IR; Instruction Register)**

   해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장하는 레지스터이다. 제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석한 뒤 제어 신호를 내보낸다.

3. **메모리 주소 레지스터 (Mar; Memory Address Register)**

   메모리의 주소를 저장하는 레지스터이다. CPU가 읽어 들이고자 하는 주소 값을 주소 버스로 보낼 때 메모리 주소 레지스터를 거치게 된다.

4. **메모리 버퍼 레지스터 (MBR; Memory Buffer Register)**

   메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터이다. 즉, 메모리에 쓰고 싶은 값이나 메모리로부터 전달받은 값은 메모리 버퍼 레지스터를 거친다. CPU가 주소 버스로 내보낼 값이 주소 레지스터를 거친다면, 데이터 버스로 주고받을 값은 메모리 버퍼 레지스터를 거친다. 메모리 데이터 레지스터(MDR; Memory Data Register)라고도 불린다.

5. **범용 레지스터 (general purpose register)**

   다양하고 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터이다. 데이터와 주소를 모두 저장할 수 있다. 일반적으로 CPU 안에는 여러 개의 범용 레지스터들이 있다.

6. **플래그 레지스터 (flag register)**

   ALU 연산 결과에 따른 플래그를 저장하는 곳이다. 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장하는 레지스터이다.

**메모리에 저장된 프로그램 실행 과정**

1. 프로그램 실행 시 프로그램 카운터에 메모리에서 가져올 명령어의 주소가 저장된다.
2. 명령어의 주소를 읽기 위해서 주소 버스로 내보낸 후, 메모리 주소 레지스터에 저장된다.
3. ‘메모리 읽기’ 제어 신호와 메모리 주소 레지스터 값이 각각 제어 버스와 주소 버스를 통해 메모리로 보내진다.
4. 메모리 주소에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 증가되어 다음 명령어를 읽어 들일 준비를 한다.
5. 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동한다.
6. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킨다.

CPU가 메모리 속 프로그램을 순차적으로 읽어 들이고 실행해 나갈 수 있는 이유는 CPU 속 프로그램 카운터가 꾸준히 증가하기 때문이다. 프로그램이 차례대로 실행되지 않고 다른 값으로 업데이트 되는 경우가 있다.

명령어 중 JUMP, CONDITIONAL JUMP, CALL, RET와 같이 특정 메모리 주소로 실행 흐름을 이동하는 명령어가 실행되었을 때와 인터럽트가 발생했을 때이다. 이런 경우 프로그램 카운터에는 변경된 주소가 저장된다.

### 특정 레지스터를 이용한 주소 지정 방식 : **스택 주소 지정 방식**

프로그램 카운터, 스택 포인터, 베이스 레지스터는 주소 지정에 사용될 수 있는 특별한 레지스터이다. **스택포인터**는 스택 주소 지정 방식이라는 주소 지정 방식에 사용되고, 프로그램 카운터와 베이스 레지스터는 변위 주소 지정 방식이라는 주소 지정 방식에 사용된다.

**스택 주소 지정 방식**

스택과 스택 포인터를 이용한 주소 지정 방식이다. 스택은 한쪽 끝이 막혀있는 통과 같은 저장 공간으로, 가장 최근에 저장하는 값부터 꺼낼 수 있다. 스택 포인터란 스택의 꼭대기를 가리키는 레지스터로, 스택의 어디까지가 채워져있는지에 대한 표시이다.

스택은 메모리 안에 사용할 스택 영역이 정해져 있다. 이 영역은 다른 주소 공간과는 다르게 스택처럼 사용하기로 암묵적으로 약속된 영역이다.

### 특정 레지스터를 이용한 주소 지정 방식 : **변위 주소 지정 방식**

오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 주소 지정 방식이다. 변위 주소 지정 방식을 사용하는 명령어는 연산 코드 필드, 레지스터 필드, 오퍼랜드 필드가 있다.

변위 주소 지정 방식은 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정 방식, 베이스 레지스터 주소 지정 방식 등으로 나뉜다.

**상대 주소 지정 방식**

오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식이다. 상대 주소 지정 방식은 프로그래밍 언어의 if 문과 유사하게 모든 코드를 실행하는 것이 아닌, 분기하여 특정 주소의 코드를 실행할 때 사용된다.

**베이스 레지스터 주소 지정 방식**

오퍼랜드와 베이스 레지스터 값을 더하여 유효 주소를 얻는 방식이다.

베이스 레지스터는 기준 주소, 오퍼랜드는 기준 주소로부터 떨어진 거리로서의 역할을 한다. 베이스 레지스터 주소 지정 방식은 베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지를 연산하여 유효 주소를 얻어내는 방식이다.

## 04-3. 명령어 사이클과 인터럽트

### 명령어 사이클

CPU가 하나의 명령어를 처리하는 과정에는 흐름이 있고, 흐름을 반복하여 명령어들을 처리해 나간다. 하나의 명령어를 처리하는 정형화된 흐름을 **명령어 사이클**이라고 한다.

CPU는 정해진 흐름에 따라 명령어를 처리해 나가지만, 흐름이 끊어지는 상황이 발생할 수도 있다. 이것을 인터럽트라고 한다.

**메모리에 저장된 명령어 실행**

1. 명령어를 메모리에서 CPU로 가져오는 단계 - **인출 사이클 (fetch cycle)**
2. CPU로 가져온 명령어를 실행하는 단계 - **실행 사이클 (execution cycle)**
   - 제어 장치가 명령어 레지스터에 담긴 값을 해석하고 제어 신호를 발생시키는 단계

어떤 명령어는 인출 사이클과 실행 사이클만 실행되고, 어떤 명령어는 명령어를 실행하기 위해서 필요한 과정이 더 있을 수도 있다. 이것을 간접 사이클이라고 한다.

### 인터럽트

CPU의 정상적인 작업을 방해하는 신호를 인터럽트라고 한다.

**동기 인터럽트 (synchronous interrupts)**

CPU에 의해 발생하는 인터럽트이다. CPU가 명령어들을 수행하다가 예상치 못한 상황에 마주쳤을 때 발생하는 인터럽트로 예외(exception)이라고 불린다.

**비동기 인터럽트 (asynchronous interrupts)**

주로 입출력장치에 의해 발생하는 알림 역할을 하는 인터럽트이다. 일반적으로 비동기 인터럽트를 인터럽트 또는 하드웨어 인터럽트라고 한다.

### 하드웨어 인터럽트

하드웨어 인터럽트는 알림과 같은 인터럽트이다. CPU는 입출력 작업 도중에도 효율적으로 명령어를 처리하기 위해 하드웨어 인터럽트를 사용한다.

하드웨어 인터럽트에는 인터럽트 플래그로 막을 수 있는 인터럽트와 막을 수 없는 인터럽트가 있다. 막을 수 없는 인터럽트는 정전이나 하드웨어 고장으로 인한 인터럽트이다.

**하드웨어 인터럽트 처리 순서**

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다.
   - 인터럽트 요쳥 신호 : CPU의 정상적인 실행 흐름을 끊기전에 다른 인터럽트가 보내는 신호
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.
   - 인터럽트 플래그 : 하드웨어 인터럽트를 받아들일지, 무시할지 결정하는 플래그
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다.
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.
   - 인터럽트 서비스 루틴 : 인터럽트를 처리하기 위한 프로그램, 인터럽트 핸들러라고도 불린다.
   - 인터럽트 벡터 : 인터럽트 서비스 루틴을 식별하기 위한 정보이다. 인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작 주소를 알 수 있기 때문에 CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다.
6. 인터럽트 서비스 루틴이 끝나면 백업해 둔 작업을 복구하여 실행을 재개한다.

### 예외의 종류

예외가 발생하면 CPU는 하던 일을 중단하고 해당 예외를 처리한다. 예외를 처리하고 나면 CPU는 다시 본래 하던 작업으로 되돌아와 실행을 재개한다.

**폴트**

예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외이다.

**트랩**

예외를 처리한 직후 예외가 발생한 명령어의 다음 명령어부터 실행을 재개하는 예외이다. 주로 디버깅을 할 때 사용된다.

> **디버깅**
>
> 프로그램 개발 중에 발생한 문제를 진단하고 해결하기 위한 작업

**중단**

CPU가 실행 중인 프로그램을 강제로 중단시킬 수 밖에 없는 심각한 오류를 발견했을 때 발생하는 예외

**소프트웨어 인터럽트**

시스템 호출이 발생했을 때 나타난다.
